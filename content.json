{"meta":{"title":"single's blog","subtitle":"","description":"","author":"Single","url":"https://single-smile.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-07-29T14:07:31.000Z","updated":"2022-07-29T14:09:57.705Z","comments":true,"path":"categories/index.html","permalink":"https://single-smile.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-29T13:55:44.000Z","updated":"2022-07-29T14:03:02.072Z","comments":true,"path":"tags/index.html","permalink":"https://single-smile.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"信号与模电","slug":"simulation-electron","date":"2022-10-20T07:43:35.000Z","updated":"2022-10-27T02:20:41.733Z","comments":true,"path":"simulation-electron/","link":"","permalink":"https://single-smile.github.io/simulation-electron/","excerpt":"信号与系统线性系统：输入的线性组合产生响应的线性组合变换就是一个系统$y_{zs}$ $zs$ &#x3D; zero status$y_{zi}$ $zi$ &#x3D; zero input","text":"信号与系统线性系统：输入的线性组合产生响应的线性组合变换就是一个系统$y_{zs}$ $zs$ &#x3D; zero status$y_{zi}$ $zi$ &#x3D; zero input 完全响应：$y(\\cdot)&#x3D;T[{f(\\cdot)},{x(0)}] $零状态响应：$y(\\cdot)&#x3D;T[{f(\\cdot)},{0}]$零输入响应：$y(\\cdot)&#x3D;T[{0},{x(0)}] $ 时不变系统：系统输入延迟多少时间，其零状态响应也相应延迟多少时间。（不考虑$x(0)$） 模拟电路预备知识电容元件定义：一个二端元件，在任意时期$t$，它所积累的电荷$q(t)$与端电压$u(t)$之间的关系可以用$q$-$u$平面上的一条曲线来确定，则称该二端元件为电容元件，简称电容。 电容的单位为法拉，简称法，符号为$F$ 电容元件电流不取决与该时刻电容电压的大小，而取决于该时刻的电容电压的变化率，所以电容元件称为动态元件。 电容微分形式$VCR:$ $i&#x3D;C\\frac {du}{dt}$ 电容电压只能连续变化而不能发生跳变，这说明电容电压只能是时间$t$的连续函数，这种性质称为电容的惯性，电容元件也称为惯性元件。 电容积分形式$VCR:$ $u(t)&#x3D;\\frac 1C\\int^t _{-\\infty}i(\\xi)d\\xi$ 任意时刻$t$电容电压并不取决于该时刻的电流值，而是取决于$-\\infty$到$t$所有的时刻的电流值，即与$t$以前电容电流的全部历史有关。电容电压能反映又去电流作用的全部历史，因此可以说电容电压有“记忆”电流的作用。电容是一种“记忆元件” 电容元件是一个储能元件而不是耗能元件。 叠加定理：对于具有唯一解的线性电路，如果有多个独立源同时作用，则电路中任一响应（电流或电压）等于各个独立源单独作用（其他独立源置零）时在该处所产生的分响应（电流或电压）的代数和。齐次性定理：在线性电阻电路中，若电路只有一个激励（独立电压源或独立电流源）作用，则电路中的任意响应（电压或电流）和激励成正比；若电路中含有多个激励，则当所有激励（独立电压源或独立电流源）都同时增大或缩小$k$倍时（$k$为任意实常数），电路响应也将相应增大或缩小$k$倍。戴维南定理：任意一个线性有源二端网络，就其输入端而言总可与一个独立电压源和一个线性电阻串联的电路等效。其中独立电压源的电压等于该二端网络输出端的开路电压$u_{oc}$；串联电阻$R_0$等于将该二端网络内所有独立源置零时输出端的等效电阻。 非线性电阻的串、并联运算可以使用解析法或图解法来实现。 双极晶体管（三极管）$B:base$基极$E:emission$发射极，发射载流子的$C:collection $集电极 $i_B$：直流和交流都存在的瞬时值$I_B$：直流$\\dot I_b$：正弦交流量的向量$i_b$：（正弦）交流分量$I_b$：正弦交流量的有效值 三极管→：由P→N，发射结导通的方向 发射区：重参杂 N型半导体：也称为电子型半导体。N型半导体即自由电子浓度远大于空穴浓度的杂质半导体。 发射结：基区与发射区形 成的结集电结：基区与集电区形成的结发射结正偏 N&#x2F;P沟道增强型绝缘栅型场效应管（MOS管）$g:grid$栅极$s:source$源极$d:drain$漏极 N沟道结型场效应管 场效应管参数 直流参数：$U_{GS(th)}$ $U_{GS(off)}$ $I_{DSS}$ $R_{GS(DC)}$ 交流参数： 跨导（低频）$g_m&#x3D;\\frac{\\Delta i_D}{\\Delta U_{GS}}|{U{DS}&#x3D;常数}$ 极间电容 $BJT$共射特性曲线 输入特性曲线 $i_c&#x3D;f(u_{BE})$ $U_{CE}&#x3D;常数$ 输出特性曲线$i_c&#x3D;f(u_{CE})$ $i_B&#x3D;常数$ 虽然内部根据电压原则集电极处于正偏状态，但集电结内电子流动属性不是按照正偏二极管方向，而是依然按照三极管集电结扩散运动方向 直接耦合共射放大电路阻容耦合共射放大电路 共射电流放大系数：$$\\overline\\beta &#x3D; \\frac {I_{CN}}{I_{BN}}&#x3D;\\frac{I_C-I_{CBO}}{I_B+I_{CBO}}\\approx\\frac {I_c}{I_B}$$ $$\\beta&#x3D;\\frac {\\Delta {I_C}}{\\Delta {I_B}}$$ 穿透电流：$I_{CEO}$共基电流放大系数：$$\\overline\\alpha&#x3D;\\frac {I_C}{I_E}&#x3D;\\frac{\\overline\\beta}{1+\\overline\\beta}$$ $PN$结每升高一度，正向导通压降小$2$~ $2.5mv$，反向导通，每十度翻一倍。 温度升高，$\\beta$增大 放大电路的性能指标 放大倍数：$A_{uu}$ $A_{ui}$ $A_{iu}$ $A_{ii}$ $R_i$放大电路的输入等效电阻，越大越好 $R_o$放大电路的输出等效电阻 通频带，放大电路的工作频率 非线性失真 最大不失真输出电压 最大输出功率与效率 放大电路的分析方法直流通路$u_i&#x3D;0$ 交流通路 直流源置0 电容→短路 等效电路法 Q点 $r_{be}&#x3D;r_{bb’}+(1+\\beta)\\frac {U_{T}}{I_{EQ}}$ 给出$U_{BEQ}$相当于在二极管中给出了开通电压$rbb’$代表基区体电阻 解题思路 静态 直流通路 $V_{CC}&#x3D;U_{BEQ}+I_{BQ}\\cdot R_B$ $I_{EQ}&#x3D;(1+\\beta)I_{BQ}$ $→I_{EQ}&#x3D;?$ 动态 交流通路 (简化)h参数等效 $A_u&#x3D;\\frac {u_0}{u_i}&#x3D;\\frac {-ic\\cdot R_L\\parallel R_C}{i_b \\cdot r_{be}}&#x3D;\\frac{-\\beta\\cdot R_L\\parallel R_C}{r_{be}} $ $R_i&#x3D;R_B\\parallel r_{be}$ $R_0$越小输出端越近似于电压源$R_0$越大输出端越近似于电流源","categories":[],"tags":[{"name":"信号与模电","slug":"信号与模电","permalink":"https://single-smile.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A8%A1%E7%94%B5/"}]},{"title":"DIY键盘教程（一）配置USB HID","slug":"keyboard-usb-hid","date":"2022-08-22T10:51:16.000Z","updated":"2022-08-22T10:57:44.518Z","comments":true,"path":"keyboard-usb-hid/","link":"","permalink":"https://single-smile.github.io/keyboard-usb-hid/","excerpt":"首先键盘使用的主控是stm32f401CCU6，开发方式为cubemx+keil。键盘主要采用的是USB HID+矩阵键盘扫描，灯光部分使用的是ws2812。此教程适合有一定stm32基础的人。","text":"首先键盘使用的主控是stm32f401CCU6，开发方式为cubemx+keil。键盘主要采用的是USB HID+矩阵键盘扫描，灯光部分使用的是ws2812。此教程适合有一定stm32基础的人。 ##Cubemx配置 首先用cubemx新建一个工程 选择USB_OTG_FS(有的芯片是USB) mode里选择Device_Only 然后Middleware里选择USB_DEVICE Class For FS IP 里选择Human Interface Device Class(HID) 其中VID和PID可以改成任意你喜欢的值，MANUFACTURER_STRING改成任意你喜欢的值 最后生成代码 keil配置 打开usb_hid.c文件 在文件中搜索HID_MOUSE_ReportDesc（ctrl+f） 因为cubemx默认是生成鼠标报告描述符，所以要将其替换为键盘报告描述符 所以将鼠标描述符内容替换成以下键盘报告描述符内容即可 12345678910111213141516171819202122232425262728293031323334char ReportDescriptor[63] = &#123; 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x06, // USAGE (Keyboard) 0xa1, 0x01, // COLLECTION (Application) 0x05, 0x07, // USAGE_PAGE (Keyboard) 0x19, 0xe0, // USAGE_MINIMUM (Keyboard LeftControl) 0x29, 0xe7, // USAGE_MAXIMUM (Keyboard Right GUI) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x01, // REPORT_SIZE (1) 0x95, 0x08, // REPORT_COUNT (8) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x95, 0x01, // REPORT_COUNT (1) 0x75, 0x08, // REPORT_SIZE (8) 0x81, 0x03, // INPUT (Cnst,Var,Abs) 0x95, 0x05, // REPORT_COUNT (5) 0x75, 0x01, // REPORT_SIZE (1) 0x05, 0x08, // USAGE_PAGE (LEDs) 0x19, 0x01, // USAGE_MINIMUM (Num Lock) 0x29, 0x05, // USAGE_MAXIMUM (Kana) 0x91, 0x02, // OUTPUT (Data,Var,Abs) 0x95, 0x01, // REPORT_COUNT (1) 0x75, 0x03, // REPORT_SIZE (3) 0x91, 0x03, // OUTPUT (Cnst,Var,Abs) 0x95, 0x06, // REPORT_COUNT (6) 0x75, 0x08, // REPORT_SIZE (8) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x65, // LOGICAL_MAXIMUM (101) 0x05, 0x07, // USAGE_PAGE (Keyboard) 0x19, 0x00, // USAGE_MINIMUM (Reserved (no event indicated)) 0x29, 0x65, // USAGE_MAXIMUM (Keyboard Application) 0x81, 0x00, // INPUT (Data,Ary,Abs) 0xc0 // END_COLLECTION&#125;; 然后将所有的HID_MOUSE_ReportDesc改为HID_KEYBOARD_ReportDesc（ctrl+h） 如下图所示： 打开usbd_hid.h文件 找到#define HID_MOUSE_REPORT_DESC_SIZE 74U（ctrl+f）替换为#define HID_KEYBOARD_REPORT_DESC_SIZE 63U 将所有文件中的HID_MOUSE_REPORT_DESC_SIZE替换为HID_KEYBOARD_REPORT_DESC_SIZE（ctrl+h） 然后找到红线那一行，0x02改为0x01，注释里说了1为键盘 打开usb_device.h文件添加一行extern USBD_HandleTypeDef hUsbDeviceFS; 在main.c添加头文件**#include “usbd_hid.h”**及以下试验代码 12345678910111213141516171819 /* USER CODE BEGIN 2 */uint8_t report[8]=&#123;0&#125;; /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) &#123; HAL_Delay(2000); report[2] = 4; USBD_HID_SendReport(&amp;hUsbDeviceFS,report,8); HAL_Delay(20); report[2] = 0; USBD_HID_SendReport(&amp;hUsbDeviceFS,report,8); HAL_Delay(1000); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ &#125; 编译烧录 打开记事本 stm32通过type-c连接至电脑。 两秒钟后不断打印aaaa…则配置成功🥳 ##未完待续。。。","categories":[],"tags":[{"name":"keyboard","slug":"keyboard","permalink":"https://single-smile.github.io/tags/keyboard/"}]},{"title":"wordpress搭建个人博客网站","slug":"create-blog","date":"2022-07-29T12:33:15.000Z","updated":"2022-08-22T10:57:29.508Z","comments":true,"path":"create-blog/","link":"","permalink":"https://single-smile.github.io/create-blog/","excerpt":"现在开发网站可比以前容易的多了，只要在电脑上点点几下，你就能拥有一台自己的服务器，这里我选择阿里服务器。主要用的是宝塔+wordpress，甚至你不需要写一行代码，就能拥有自己的个人网站。","text":"现在开发网站可比以前容易的多了，只要在电脑上点点几下，你就能拥有一台自己的服务器，这里我选择阿里服务器。主要用的是宝塔+wordpress，甚至你不需要写一行代码，就能拥有自己的个人网站。 安装宝塔首先使用SSH远程连接到服务器，再输入以下指令即可。yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec注意我使用的系统是centos7，其他系统请查看官网链接宝塔面板下载，免费全能的服务器运维软件 (bt.cn) 安装成功后会有以下信息，然后根据提示输入网址及用户密码就可以登录宝塔面板啦😘 之后你会看到安装在云服务器上的宝塔面板，有关于你服务器的各种信息。 初次进入面板会提示安装套件，建议选择编译安装，php建议选高一点，比如php7.4，对wordpress兼容性好。 安装wordpress在软件商店里搜寻wordpress，选择一键部署。 然后输入你的域名即可。记住数据库名称和密码，不记也没关系，可在宝塔面板-数据库-查看密码中找到。 之后会出现以下弹窗，点击访问站点即可 最后根据提示安装即可。 last but not least，我们的网站就建好了，点击查看站点。你就可以看到你的网站了。","categories":[],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://single-smile.github.io/tags/wordpress/"}]},{"title":"learning ros","slug":"leaning-ros","date":"2022-05-17T15:55:58.000Z","updated":"2022-08-02T10:15:41.096Z","comments":true,"path":"leaning-ros/","link":"","permalink":"https://single-smile.github.io/leaning-ros/","excerpt":"“learning ROS” 12345mkdir -p demo01_ws/srccd demo01_ws/catkin_makecd srccatkin_create_pkg helloworld roscpp rospy std_msg","text":"“learning ROS” 12345mkdir -p demo01_ws/srccd demo01_ws/catkin_makecd srccatkin_create_pkg helloworld roscpp rospy std_msg 1234567#include &quot;ros/ros.h&quot;int main (int argc, char *argv[])&#123; ros::init(argc, argv, &quot;hello_node&quot;); ROS_INFO(&quot;hello world&quot;); return 0;&#125; 12add_executable(haha src/helloworld_c.cpp)target_link_libraries(haha $&#123;catkin_LIBRARIES&#125;) 123roscoresource ./devel/setup.bashrosrun helloworld haha 12345&lt;launch&gt; &lt;node pkg = &quot;turtlesim&quot; type = &quot;turtlesim_node&quot; name = &quot;turtle_GUI&quot;/&gt; &lt;node pkg = &quot;turtlesim&quot; type = &quot;turtle_teleop_key&quot; name = &quot;turtle_key&quot;/&gt; &lt;node pkg = &quot;hello_vscode&quot; type = &quot;hello_vscode_c&quot; name = &quot;hello&quot; output = &quot;screen&quot;/&gt;&lt;/launch&gt; 123456rospack listrospack find turtlesimroscd turtlesimrosls turtlesimapt search ros-noetic-* | grep -i gmappingrosrun rqt_grah rqt_grah 123456789101112131415161718192021222324252627#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;int main (int argc, char *argv[])&#123; ros::init(argc, argv, &quot;erGouZi&quot;); ros::NodeHandle nh; ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;fang&quot;, 10); std_msgs::String msg; ros::Rate rate(10); int count = 0; ros::Duration(3).sleep(); while (ros::ok()) &#123; count++; std::stringstream ss; ss &lt;&lt; &quot;hello ---&gt;&quot; &lt;&lt; count; //msg.data = &quot;hello&quot;; msg.data = ss.str(); pub.publish = (msg); ROS_INFO(&quot;The published data is:%s&quot;, ss.str().c_str()); rate.sleep(); &#125; return 0;&#125; 12add_executable(demo01_pub src.demo01_pub.cpp)target_link_libraries(demo01_pub $&#123;catkin_LIBRARIES&#125;) 12345678910111213141516#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;void doMsg(const std_msgs::String::ConstPtr &amp;msg)&#123; ROS_INFO(&quot;cuiHua subsription data:%s&quot;, msg-&gt;data.c_str())&#125;int main(int argc, char *argv[])&#123; ros::init(argc, argv, &quot;cuiHua&quot;); ros::NodeHandle nh; ros::Subscriber sub = nh.subcribe(&quot;fang&quot;, 10, doMsg); ros::spin(); return 0;&#125; 12add_executable(demo02_sub src/deom02_sub.cpp)target_link_libraries(demo01_pub $&#123;catkin_LIBARIES&#125;) 1rqt_graph Person.msg 123string nameint32 agefloat32 height package.xml 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; CMakeLists.txt 1234567891011121314151617find_package(cakin REQUIRED COMPONENTSroscpprospystd_msgsmessage_generation)add_message_files(FILESPerson.msg)generate_messages(DEPENDENCIESstd_msgs)catkin_package(CATKIN_DEPENDS roscpp rospy std_msgs message_runtime) demo3_pub_person.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;ros/ros.h&quot;#include &quot;plumbing_pub_sub/Person.h&quot;/* publisher:The publisher&#x27;s message 1.Include header files #include &quot;plumbing_pub_sub/Person.h&quot; 2.Initialize the ROS node 3.Create a node handle 4.Create a publisher object 5.Write release logic and release data*/int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ROS_INFO(&quot;This is the publisher of the message&quot;) // 2.Initialize the ROS node ros::init(argc, argv, &quot;banZhuRen&quot;); // 3.Create a node handle ros::NodeHandle nh; // 4.Create a publisher object ros::Publisher pub = nh.advertise&lt;plumbing_pub_sub::Person&gt;(&quot;liaoTian&quot;, 10); // 5.Write release logic and release data // 5-1.Create published data plumbing_pub_sub::Person person; person.name = &quot;single&quot;; person.age = 1; person.height = 1.73; // 5-2.Setting the publication frequency ros::Rate rate(1); // 5-3.Circular release the data while(ros::ok()) &#123; person.age += 1; pub.publish(person); ROS_INFO(&quot;Published message:%s,%d,%.2f&quot;, person.name.c_str(), person.age, person.height); rate.sleep(); ros::spinOnce(); &#125; return 0;&#125; CMakeLists.txt 123add_executable(demo03_pub_person src/demo03_pub_person.cpp)target_link_libraries(demo03_pub_person $&#123;catkin_LIBRARIES&#125;)add_dependencies(demo03_pub_person $&#123;PROJECT_NAME&#125;_generate_messages_cpp) 12souce ./devel/setup.bashrostopic echo liaoTian demo04_sub_person.cpp 123456789101112131415161718192021222324252627282930#include &quot;ros/ros.h&quot;#include &quot;plumbing_pub_sub/Person.h&quot;/* Subscriber:Subscribes to message 1.Include header files #include &quot;plumbing_pub_sub/Person.h&quot; 2.Initialize the ROS node 3.Create a node handle 4.Create a subsriber object 5.Process subscription data 6.Call the &#x27;spin()&#x27; function*/void doPerson(const plumbing_pub_sub::Person::ConstPtr&amp; person)&#123; ROS_INFO(&quot;Subscriber information:%s,%d,%.2f&quot;, person-&gt;name.c_str(), person-&gt;age, person-&gt;height)&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL, &quot;&quot;); ROS_IFNO(&quot;Subscriber implementation&quot;); // 2.Initialize the ROS node ros::init(argc, argv, &quot;jiaZhang&quot;); // 3.Create a node handle ros::NodeHandle nh; // 4.Create a subsriber object ros::Subscriber sub = nh.subscribe(&quot;liaoTian&quot;, 10, doPerson); ros::spin(); return 0;&#125; CMakeLists.txt 123add_executable(demo04_sub_person src/demo04_sub_person.cpp)add_dependencies(demo04_sub_person $&#123;PROJECT_NAME&#125;_generate_messages_cpp)target_link_libraries(demo04_sub_person $&#123;catkin_LIBRARIES&#125;) rqt_graph AddInts.srv 1234int32 numl1int32 numl2---int32 sum package.xml 12&lt;bulid_depend&gt;message_generation&lt;/bulid_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; CMakeLists.txt 1234567891011121314151617181920find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation)add_service_files( FILES AddInts.srv)generate_messages( DEPENDENCIES std_msgs)catkin_package(CATKIN_DEPENDA roscpp rospy std_msgs message_runtime) demo01_server.cpp 12345678910111213141516171819202122232425262728#include &quot;ros/ros.h&quot;#include &quot;plumbing_server_client/ADDInts.h&quot;/* Server-side implementation:parses the data submitted by the client, calculates and generates a response*/bool doNums(plumbing_server_client::AddInts::Request &amp;request, plumbing_server_client::AddInts::Response &amp;response)&#123; int num1 = request.num1; int num2 = request.num2; ROS_INFO(&quot;Request data received:num1 = %d, num2 = %d&quot;, num1, num2); int sum = num1 + num2; response.sum = sum; ROS_INFO(&quot;Sum result: sum = %d&quot;, sum); return true;&#125;int main(int argc, char *argv[])&#123; setlocale(LC_ALL,&quot;&quot;); ros::init(argc, argv, &quot;heiShui&quot;); ros::NodeHandle nh; ros::ServiceServer server = nh.advertiseService(&quot;addInts&quot;, doNums); ros::spin(); &#125; CMakeLists.txt 12345add_executable(demo01_server src/demo01_server.cpp)add_dependencies(demo01_server $&#123;PROHECT_NAME&#125;_gencpp)target_link_libraries(demo01_server $&#123;catkin_LIBRARIES&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;robot name = &quot;mycar&quot;&gt; &lt;link name = &quot;base_footprint&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size = &quot;0.0001 0.0001 0.0001&quot; /&gt; &lt;!-- &lt;cylinder radius = &quot;0.1&quot; length = &quot;2&quot;/&gt; --&gt; &lt;!-- &lt;sphere radius = &quot;1&quot; /&gt; --&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name = &quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size = &quot;0.3 0.2 0.1&quot; /&gt; &lt;!-- &lt;cylinder radius = &quot;0.1&quot; length = &quot;2&quot;/&gt; --&gt; &lt;!-- &lt;sphere radius = &quot;1&quot; /&gt; --&gt; &lt;/geometry&gt; &lt;origin xyz = &quot;0 0 0&quot; rpy = &quot;0 0 0&quot;/&gt; &lt;material name = &quot;car_color&quot;&gt; &lt;color rgba = &quot;0.5 0.3 0.7 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name = &quot;camera&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size = &quot;0.02 0.05 0.05&quot; /&gt; &lt;!-- &lt;cylinder radius = &quot;0.1&quot; length = &quot;2&quot;/&gt; --&gt; &lt;!-- &lt;sphere radius = &quot;1&quot; /&gt; --&gt; &lt;/geometry&gt; &lt;origin xyz = &quot;0 0 0.025&quot; rpy = &quot;0 0 0&quot;/&gt; &lt;material name = &quot;camare_color&quot;&gt; &lt;color rgba = &quot;0.7 0.2 0.3 0.5&quot;/&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt; &lt;joint name = &quot;link2footprint&quot; type = &quot;fixed&quot;&gt; &lt;parent link = &quot;base_footprint&quot;/&gt; &lt;child link = &quot;base_link&quot;/&gt; &lt;origin xyz = &quot;0 0 0.05&quot; rpy = &quot;0 0 0&quot;/&gt; &lt;/joint&gt; &lt;joint name = &quot;camera2base&quot; type = &quot;continuous&quot;&gt; &lt;parent link = &quot;base_link&quot;/&gt; &lt;child link = &quot;camera&quot;/&gt; &lt;origin xyz = &quot;0.12 0 0.05&quot; rpy = &quot;0 0 0&quot;/&gt; &lt;axis xyz = &quot;0 0 1&quot;/&gt; &lt;/joint&gt;&lt;/robot&gt;","categories":[],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://single-smile.github.io/tags/ROS/"}]},{"title":"foc","slug":"foc","date":"2022-04-12T08:30:00.000Z","updated":"2022-08-22T10:59:50.425Z","comments":true,"path":"foc/","link":"","permalink":"https://single-smile.github.io/foc/","excerpt":"“learning foc”","text":"“learning foc” 代码12345678int Vd = 0;int Vq = 1;float theta = 0.0;float Valpha = 0.0;float Vbeta = 0.0;float out1 = 0.0;float out2 = 0.0;float out3 = 0.0; 12345678910111213141516171819202122 while (1) &#123; theta = angle; Valpha = Vd * cos(theta) - Vq * sin(theta); Vbeta = Vd * sin(theta) + Vq * cos(theta); out1 = Valpha; out2 = (-Valpha + Vbeta * sqrt(3)) / 2; out3 = (-Valpha - Vbeta * sqrt(3)) / 2; //上面是为了产生三相正弦波 TIM3-&gt;CCR1 = ((out1 + 1) / 2) * 1000; TIM3-&gt;CCR2 = ((out2 + 1) / 2) * 1000; TIM3-&gt;CCR3 = ((out3 + 1) / 2) * 1000;//这是调制pwm /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ &#125; 12345678910void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim == (&amp;htim5)) &#123; angle +=0.1; if (angle &gt; 3.1415926*2) angle = 0; &#125;&#125; 代码解释 首先单片机开三个pwm输出引脚。 angle 变量放在一个定时器中断里面。从0到2Π递增，到2Π归零。产生锯齿波形。锯齿波形的周期越短，得出的三相正弦波周期越短。电机转速越快。想要改变转速即改变中断的频率，即对应定时器ARR的值。&#x3D;&#x3D;ARR越大电机转的越慢.&#x3D;&#x3D; 后面的数学运算都是为了将Vd，Vq，angle，变成三相正弦波。控制这三个参数改变正弦波的周期，幅值。用到反park变换，反clark变换等。 最后是将产生的三相正弦波，调制成pwm波。 图像说明Vq Vd angle 的图像： 三相正弦波图像： pwm调制： 资料链接【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术 - 知乎 (zhihu.com) FOC视频教程_哔哩哔哩_bilibili 彻底搞懂两电平SVPWM调制原理及其仿真_哔哩哔哩_bilibili","categories":[],"tags":[{"name":"foc","slug":"foc","permalink":"https://single-smile.github.io/tags/foc/"}]},{"title":"math","slug":"math","date":"2022-03-29T16:00:00.000Z","updated":"2022-03-31T01:55:01.295Z","comments":true,"path":"math/","link":"","permalink":"https://single-smile.github.io/math/","excerpt":"Differential equation","text":"Differential equation 特征方程的根 微分方程通解中的对应项 单实根 $r$一对单共轭复根$r_{1,2}&#x3D;\\alpha\\pm i\\beta$$k$ 重实根 $r$ $k$ 重共轭复根 $r_{1,2}&#x3D;\\alpha\\pm i\\beta$ 给出一项 $e^{rx}$给出两项$e^{\\alpha x}\\cos\\beta x,e^{\\alpha x}\\sin \\beta x$给出 $k$ 项 $e^{rx},xe^{rx},x^2e^{rx},\\cdots,x^{k-1}e^{rx}$给出 $2k$项 $e^{\\alpha x}\\cos\\beta x,xe^{\\alpha x}\\cos\\beta x,\\cdots,x^{k-1}e^{\\alpha x}\\cos\\beta x,$ $e^{\\alpha x}\\sin\\beta x,xe^{\\alpha x}\\sin\\beta x,\\cdots,x^{k-1}e^{\\alpha x}\\sin\\beta x.$ 情形Ⅱ $f(x)&#x3D;e^{\\lambda x}[P_l(x)\\cos\\omega x+P_n(x)\\sin\\omega x]$，$P_l(x)$,$P_n(x)$分别为 $l$ , $n$ 次多项式$$k&#x3D;\\begin{cases}0,&amp;\\lambda\\pm i\\omega 不是特征根,\\1,&amp;\\lambda\\pm i\\omega 是特征单根,\\s,&amp;\\lambda\\pm i\\omega 是s重特征根.\\end{cases}$$","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://single-smile.github.io/tags/math/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-29T14:46:10.976Z","updated":"2022-03-30T07:40:46.596Z","comments":true,"path":"hello-world/","link":"","permalink":"https://single-smile.github.io/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"信号与模电","slug":"信号与模电","permalink":"https://single-smile.github.io/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A8%A1%E7%94%B5/"},{"name":"keyboard","slug":"keyboard","permalink":"https://single-smile.github.io/tags/keyboard/"},{"name":"wordpress","slug":"wordpress","permalink":"https://single-smile.github.io/tags/wordpress/"},{"name":"ROS","slug":"ROS","permalink":"https://single-smile.github.io/tags/ROS/"},{"name":"foc","slug":"foc","permalink":"https://single-smile.github.io/tags/foc/"},{"name":"math","slug":"math","permalink":"https://single-smile.github.io/tags/math/"}]}